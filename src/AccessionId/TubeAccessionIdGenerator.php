<?php

namespace App\AccessionId;

use App\Entity\Tube;
use App\Repository\TubeRepository;
use Doctrine\ORM\EntityManagerInterface;

/**
 * Generates unique Tube Accession ID
 */
class TubeAccessionIdGenerator
{
    /**
     * Text prefix added to numeric part of ID
     */
    const ID_PREFIX = 'T';

    /**
     * Maximum numeric part of Accession ID to create
     */
    const MAX_ID_INT = 99999999;

    /**
     * @var TubeRepository
     */
    private $repository;

    /**
     * @var string[] IDs generated during the lifetime of this object
     */
    private $generatedThisInstance = [];

    public function __construct(EntityManagerInterface $em)
    {
        $this->repository = $em->getRepository(Tube::class);
    }

    /**
     * Generate a unique Tube Accession ID not currently used
     */
    public function generate(): string
    {
        // Sanity check to prevent infinite loop
        $maxTries = 1000;

        $id = null;

        do {
            // Accumulate from previous loop, if exists
            if ($id) {
                $this->generatedThisInstance[] = $id;
            }

            // Generate a new ID
            $id = $this->getNextAccessionId();

            $maxTries--;
        } while ($this->idExists($id) && $maxTries > 0);

        if ($maxTries === 0) throw new \ErrorException('Unable to generate a Tube Accession ID (exceeded max tries)');

        // Store for next generate()
        $this->generatedThisInstance[] = $id;

        return $id;
    }

    private function idExists(string $id): bool
    {
        // Consider it existing if we've generated it already.
        // This makes working with unpersisted entities easier.
        if (in_array($id, $this->generatedThisInstance)) return true;

        // ID exists if it's attached to an existing record in the database
        $found = $this->repository->findOneBy(['accessionId' => $id]);

        return $found ? true : false;
    }

    /**
     * Get next available Accession ID after accounting for persisted data
     * and in-memory data from this instance.
     *
     * @return string
     */
    private function getNextAccessionId(): string
    {
        // "T00001234"
        $max = $this->getMaxAccessionId();

        // Remove leading prefix "T00001234" => "00001234"
        $oldNumber = str_replace(self::ID_PREFIX, '', $max);

        // Drop leading zeros, convert to integer
        // "00001234" => 1234
        $newInt = (int)$oldNumber;

        // Increment
        // 1234 => 1235
        $newInt++;

        if ($newInt > self::MAX_ID_INT) {
            throw new \RuntimeException('Tube Accession ID generation exceeded maximum value');
        }

        // Convert to string and re-pad with leading zeros
        // 1235 => "00001235"
        $newNumber = str_pad($newInt, 8, '0', STR_PAD_LEFT);

        // Prepend prefix
        return self::ID_PREFIX . $newNumber;
    }

    /**
     * Get maximum assigned Tube Accession ID given what's in the database
     * and already been generated by this service.
     *
     * This approach is vulnerable to race conditions between two instances,
     * but is rare enough we ignore it.
     *
     * @return string
     */
    private function getMaxAccessionId(): string
    {
        $search = $this->generatedThisInstance;
        $search[] = $this->repository->findMaxAccessionId();

        return max($search) ?: self::ID_PREFIX . '00000000';
    }
}
